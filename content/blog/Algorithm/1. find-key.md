---
title: '[Algorithm] 컵 돌리기'
date: 2019-4-29 17:00:00
category: 'Algorithm'
---
### 문제
세 개의 뒤집힌 컵 중 한 개의 컵 안에 열쇠가 있습니다.
당신이 열쇠를 찾기 위해 컵을 들어올리려는 순간, Drogon이 빠르게 컵의 위치를 뒤섞기 시작합니다.
컵의 교환이 끝났을 때, 열쇠가 들어있는 컵을 찾아야 합니다.

- 컵의 위치는 인덱스로 표현됩니다. (0부터 시작)
- 키가 들어있는 컵의 인덱스와 교환된 컵의 인덱스를 나타내는 배열(swaps)을 입력으로 받습니다. 
- 예를들어, 열쇠가 들어있는 컵의 처음 위치가 `0`이고 컵이 교환되는 순서가 다음과 같다면 [(0, 1), (1, 2), (1, 0)]
	1. 첫 교환때 열쇠가 있는 컵은 0 에서 1로 이동하게 됩니다.
	2. 두번째 교환때 열쇠가 있는 컵은 1 에서 2로 이동하게 됩니다.
	3. 마지막 교환때 1에 있는 컵이 0으로 가지만, 열쇠가 있는 컵에는 영향을 미치지 않습니다.
	4. 따라서 열쇠가 있는 컵의 위치는 2가 됩니다.
- 컵의 갯수는 최소한 두 개 이상입니다.
```js
swaps = [[0, 1], [1, 2], [1, 0]]
firstPosition = 0
findKey(firstPosition, swaps) // == 2
```

컵돌리기 문제를 분해 해보자면, 2개 이상의 컵들이 뒤집어져 있고 하나의 컵에는 키가 담겨있다. 
컵돌리기가 시작되면 컵들이 교환되면서 키를 가진 컵도 함께 섞이는데, 다행히 교환되는 데이터를 확인할 수 있다. 데이터를 활용해서 키를 가진 컵의 위치를 추적하면 된다.

일단 키를 가진 컵의 인덱스가 교환되면서 인덱스가 *변경 될 때마다 인덱스를 할당할 수* 있는 `let keyCup`이라는 `let`키워드와 함께 변수를 선언하고  `start`으로 초기값을 설정한다.
그리고 swaps의 배열의 요소가 존재하는지 먼저 확인 한다. 
swaps배열이 비어 있다면 교환될 수가 없으므로 시작할때 열쇠를 가지고 있는 컵의 인덱스를 리턴해주면 된다.
swaps배열에 요소가 있다면 배열의 값에 루프로 반복하며 접근한다. 
접근한 요소(배열)는 두 인덱스 값을 가진다. 두 인덱스 중에  keyCup의 인덱스와 일치하는 인덱스가 있다면, 교환될 또 다른 하나의 인덱스를 keyCup의 값으로 새롭게 할당해준다.
이 동작을 swaps배열의 요소들을 모두 체크하면서 반복하면 결국엔 keyCup에는 키를 가진 컵의 인덱스를 알 수 있게 된다.

코드로 구현해보았다.
```js
function findKey(start, swaps) {
  let keyCup = start;
  if (!swaps.length) {
    return keyCup;
  } else {
    for (let prop in swaps) {
      let [a, b] = swaps[prop]
      if (keyCup === a) {
        keyCup = b;
      } else if (keyCup === b) {
        keyCup = a;
      }
    }
  }
  return keyCup;
}
```
