---
title: '0722-0727'
date: 2019-7-27 16:13:10
category: 'TIL'
---
## 0722 - 0723

- 씽글쓰레드
한번에 한가지 일만 한다.

- v8 엔진
: 힙(저장 공간), 스택
 
- call stack
: 쌓이고 빠지고 를 반복
콜스택에는 함수 실행만 들어간다.
쌓인다는 것은 메모리 공간을 차지 하는 것이다. 브라우저의 메모리 공간의 제한이 있기때문에 에러메세지가 뜬다.(실제로 무한한 사이즈가 아니어도 브라우저의 사이즈를 넘는다면 제한할 수 있다.)

- Web API
: 엔진에 속한것이 아니다. (js에 속한 것이 아니다.)
여기서 시간을 재고 콜백큐로 밀어넣는다.

- callback queue
: 기본적으로 큐는 줄서는 것. 즉, 콜백이 줄서는 것이다. 

- 비동기
setTimeout =  정확한 시간을 뜻한다기 보다 ~이후에 실행이 된다는 것을 명시한다. 실제 시간을 재기 시작하는 타이밍은 웹api로 넘어오자 마자이다.
여러개의 셋타임아웃의 순서가 늦더라도 시간이 더짧다면 콜백큐로 줄을 먼저 세운다. 

-> 공통점은 이벤트 루프와 연관성이 있다.

#### Run To Completion
한번 실행되면 끝까지 실행된다. 
콜스택에 쌓여있는 것들이 모두 사라져야 콜백큐에 쌓였던 것들이 순차적으로 실행된다.
이러한 과정 중 콜스택이 비어있는지 확인하고 콜백큐의 내역을 보내주는 역할을 하는 것이 이벤트 루프이다.

실행이 종료되어야 다른 것들이 연산이 된다. 
이벤트루프는 비동기적인 것만 실행하고 담당하는 것이 아니라 다양하게 종합적으로 관장한다.
실제로 요청을 보내는 것은 Web API, 응답이 오면 화면에 업데이트해야할 내용과 등등의 것들을 줄세우는 작업을 한다. 

#### Render Queue
화면에 랜더되는 내용들을 줄세운다.
랜더 트리에는 헤드가 속하지 않는다. 실제로 화면에 보여줘야할 것들만 트리구조로 형성한다.

[rendertree](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)

이벤트 루프가 큐(job queue, callback queue, render queue)들을 확인하면서 차례로 줄세워준다.
코드상으로 나열된 내역들을 브라우저가 참고해서 랜더큐로 정보를 줄세운다.
돔이나 cssom이 변경되었을 경우에는 랜더트리를 새로 구성한다.(실제적으로는 그렇지 않을 것이지만 브라우저 내부의 로직대로 움직인다.) 
돔 -> 레이아웃 -> 페인트


### Git
버전 컨트롤 시스템
원시적인 일은 변경사항을 기억하는 것이다.
파일 변경사항을 추적해주는 프로그램
협력개발을 도와주는 프로그램
다양한 파일들을 공유하고 조율하고 협업하는 프로그램
linus benedict torvalds
- 버전 컨트롤
사용자가 코드와 그 코드의 히스토리를 사용자 컴퓨터에 보관함
인터넷 접근이 필요없음

- 스냅샷
코드 히스토리를 기억하는 방식
주어진 시점에 어떻게 생겼는지 기록한다.
시점은 선택해서 명령한다.
기록된 시점으로 볼 수 있다.

- 커밋
스냅샷을 생성하는 행위
동사, 명사로 이루어진다.
기본적으로

3가지
1) 파일 변경 사항
2) 바로 이전 커밋, 즉 "parent commit"
3) 커밋 해쉬 (고유한 값을 지닌다.)
- Repository
모든 파일들과 그 파일들의 히스토리가 모여있는 곳
개인 컴퓨터나 클라우드 서버에 있다.
클라우드에서 복사해서 다운 받는 행위는 클론
클론함으로서 협업이 가능해진다.
내 컴퓨터에 없는 내용을 클라우드로부터 추가적으로 다운로드 받는 행위를 풀이라고 한다. (유사 : 패치)
패치 : 클라우드와 내 컴퓨터의 변경사항의 차이점을 다운만 받는것이고 실제로 바뀐것이 아니므로 헤드가 바뀌지 않는다. / 머지 오리진/마스터는 브랜치에까지 다운
- Branch
모든 커밋들은 브랜치내에 존재한다.
브랜치는 아주 많이 있을 수 있다.
깃에서 항상 메인되는 브랜치는 **마스터** 브랜치이다.
보통 하나의 프로젝트는 하나의 리포, 여러개의 브랜치, 가가의 브랜치 속에는 커밋들이 있을 것이다.
- head
현재 브랜치의 가장 마지막 커밋을 보통 지칭한다.
- master
모든 프로젝트의 메인 브랜치
- create commit
파일 변경사항을 기록하고싶을때 변경사항을 스테이지에 올린다.
스테이지에 올린다는 것은 우리가 수정한 파일 내역 중에 다음 커밋에 포함하고 싶은 사항을 예약하는 것
스테이지에 올라가 있는 것만 커밋된다.
- git log
커밋 히스토리를 최신 순으로 보여준다.
- github
깃들의 허브
깃 레포지토리 호스팅 서비스 업체
버전관리하기 위해, 백업을 위해, 협업을 위해
- git connecting
깃 리모트 -v 
깃 리모트 에드
ex) 깃 리모트 에드 오리진 url
오리진 이라고 이름 짓는다.
// 리모트 브랜치에 반영하기
깃 푸쉬 오리진 마스터

## 0724

### 디자인 패턴
프레임 워크, 라이브러리 vs 디자인 패턴 등과 같은 것들은 도구일뿐이다.

### +)
- **그저 영혼 없이 도구를 쓰는 것보다는 이해하고 쓰는 사람이 된다는 것**
- 문제를 해결하기 위한 원리를 근본적으로 이해하는 것은 중요하다. 그래야 응용할 수가 있다. 

#### Advatage
- Proven 
다수의 사람들이 유사한 방법으로 사용했기때문에 검증이 된것이다.
- Reusing
유사한방법으로 사용했다는 것은 다양하게 적용할 수 있다는 것이다. (이미 준비된 재료와 같은 것)
- Expressive
어떠한 패턴을 적용했을 경우 의미를 유추해서 파악하기 쉽다. (가독성이 높다는 뜻이다.)
정확한 해결책이 되는 것이 아니라 (어느정도의 대략적인 설계도가 된다. (프로그래밍은 답이 없고 각각의 장단점이 있는 것이다.)

### 객체 생성 패턴
#### 1. 모듈
하나의 조각(like 레고블럭), 

#### 1-1 객체 리터럴

```js
let module = {
  etc: ,
  fn: function () {
  }
}

```

상황에 따라서 객체를 보호해야할 경우가 생긴다.
#### 1-2 정보 보호
함수스코프로 변수를 보호하고 변수를 조정하는 객체 리턴해주면서 보호한다.
브라우저환경은 사용자에게 직접적으로 보여지기때문에  보안적으로 취약할 수 밖에 없다. 그렇기때문에 신경써서 코딩해야한다.
글로벌에 변수를 쓰는 것을 지양하는 것이 좋다. 네임스페이스 패턴을 사용하는 이유는 많은 함수, 객체, 변수들로 전역으로 되어 선언되어 있는 것을 줄이고자 하는데 큰 목적이 있다. 

#### 팩토리 함수
도 글로벌에 속하기 떄문에 마저도 즉시실행함수로 감싸서 사용한다면 보호가 된다.
또하나의 패턴이다. 

#### Mixin
팩토리함수를 재사용하면서 공동으로 쓰는 것들이 많아질 경우. 어떠한 경우를 공유한다는 것.
큰 변화없이 **확장**이 가능한 패턴 (심플) / 코드를 재활용시켜주는 것

#### 1-3 싱글튼
객체는 참조함으로써 이뤄지는데, **단!** 하나의 객체만 생성한다는 것.

#### 코드 재사용 패턴
프로토타입 패턴

#### 체이닝

#### pub-sub
퍼블리쉬 앤 섭스크라입

## Promise
라이브러리를 사용하지 않을때 비동기적으로 코딩을 할때 가장 흔하게 사용할 수 있는 방법이다. 왜냐하면 JS에서는 함수가 일급객체이기 때문이다.

#### continuation passing style
함수를 지속적으로 넘겨 주는 것
단점은 콜백지옥에 빠질 수 있다.

`new Promise(fn)`=> 인스턴스 **객체가 반환**된다. (활용 범위가 커졌다는 것)
비동기처리를 할 수 있는 것이 도출. 
사용할 수 있는 물건이 손에 잡혔다는 것이다. 
비동기처리를 객체지향적으로 다루는 것이 가능토록 하는 것이다.
(프로미스는 콜백헬을 완벽하게 해결하는 것이 아니다. 프로미스를 써도 콜백헬이 발생할수도 있다. )

함수를 인자로 하나 받는다. 인자는 바로 호출된다. 그 함수의 인자는 리졸브와 리젝트로 받는다.
리졸브 (좋은 것)
리젝트 (나쁜 것)

인스턴스의 메소드에는
덴(함수) : 리졸브(인자로 들어간 함수가 댄의 인자로 간다)가 모두 됐을때 호출
모두 실행되고 댄이 실행된다는 것은 리졸브 과정중에 실패한 것이 없다는 인증이 됐다는 것이다.
캐치(함수) : 리젝트됐을때 호출

프롸미스는 객체지향프로그래밍에 확장성을 부여했다.

## 0725
비동기함수에 쓰이는 콜백의 첫번째 인자는 error가 들어오고 두번째 인자는 result가 들어간다.
### +) 
- 개발자 도구를 사용해서 흐름을 확인해야한다.
- 문제파악을 해야한다. 문제라고 생각하는 작업줄 상단에 디버거를 입력해서 디버깅을 한다.
- 함수가 생성되면 새롭게 스코프가 생성된다.
- map은 closure을 이용해서 각각의 변수를 새로만든 함수와 연결시켜준다.
그래서 비동기의 결과를 동기적으로 가져야할 경우 클로저를 적용해서 새로운 스코프를 만들어서 원하는 결과값을 얻을 수 있다.

## 0726
## Functional Programming
데이터 처리를 수학적 함수의 계산으로 취급한다. 명령현 프로그래밍과는 달리 상태 변경을 멀리한다. 
코드를 전반적으로 이해할 수 있어야하고 종합적으로 적용가능한 실력이 생겼을때 할수있는 패러다임이다.
수학이라는 검증된 학문을 차용해서 도입한다는 것이기 떄문에 매우 신뢰가 높다.

### Function
함수는 지켜야할 원칙이 있다.
하나의 인풋값이 하나의 아우풋값으로 도출해야한다. 하나의 인풋으로 여러개의 아우풋은 불가하지만 여러개의 인풋이 같은 아웃풋을 도출하는 것은 가능하다.
상자 내부로 인해서 동작이 되어야 한다. 

### Pure Function
부작용이 없는 함수를 순수함수라고 한다. 즉, 함수 실행이 외부에 영향을 끼치지 않는 함수이다. 그리고 매핑이라고도 한다. 
순수함수에 대해 강한 신뢰를 가지고 사용하게 되므로 순수함수를 덩확히 구현해야한다.

### composition
예를 들면 foo함수를 bar함수로 전달해줄수도 있다. 이렇게 사용되는 함수는 순수함수를 사용한 기법으로 쓰인다.
순수함수를 사용해서 병합한다면 어떤 방식이든지 같은 값이 도출된다.
#### pipe
함수를 받으면서 왼쪽부터 오른쪽으로 흘러가는 흐름이다. 
왼쪽부터 실행된 함수의 값을 오른쪽으로 넘겨보낸다.
#### compose
파이프와 반대의 방향

연산하는 상황에 많이 쓰인다.

함수 객체지향 다른 용도일뿐 따로 쓰는 것이 아니다.
데이터에 대해서 한방향으로 진행할 경우 사용한다.

## 0727
### Async 라이브러리의 기능들을 직접 구현해보기!
15가지의 기능들 모두를 나열 할수는 없겠지만 처음 `_.each`를 만들때 비동기적으로 실행되는 구문들을 이해하기가 쉽지 않았다. 침착함을 가다듬고 천천히 문제점을 찾아나갔다. 하지만 난이도가 점점 상승할 수록 손으로 쓰고 눈으로 파악하는 것으로만 디버깅할 수 없었다. 그래서 크롬의 개발자 도구를 이용해서 `debugger;`을 사용해서 디버깅하면서 문제점을 해결했다. 
#### 모든 구현을 마치고 느낀점
자바스크립트는 싱글 쓰레드 기반으로 구성되어있다. 하지만 비동기적인 요구사항들도 문제해결을 하며 느낀점은 **비동기적인 상황도 개발자가 통제할 줄알아야한다**는 것이다. 느낀점이 짧은 한 문장이지만 기능들을 직접 구현하면서 어려워서 정말 많이 애 먹었다.. 그래도 마치고나니 어렴풋이 머릿속에 들어와있고 이제 겁도 덜 난다.
