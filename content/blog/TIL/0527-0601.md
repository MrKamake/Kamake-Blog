---
title: '0527-0601'
date: 2019-6-1 19:23:51
category: 'TIL'
---
## 0527
## Pure Function
순수함수는 함수형프로그래밍에서 많이 사용된다. 
입력된 인자 값만 의존하기때문에 주어진 동일한 입력, 동일한 출력을 반환한다. 그래서 외부 상태를 변경시키는 부작용을 일으키지 않는다. 
순수한 기능이므로 적재적소에 배치해서 재사용할 수 있다. (모듈화, 재사용성)

=> 코드를 추론하기 쉽고 테스트하고 예측가능하다. 하지만 부작용에 대한 기초적인 문제를 완벽히 제거하지는 않는다.

## 0528-0529
## Default parameter
매개변수의 값에 falsy값이 있을 경우에 default parameter가 되는 것이 아니라, 단순히 그냥 값이 주어지지 않았을 경우에 디폴트값이 되는 것이다. 단, `undefined`가 값에 주어진다면 디폴값으로 지정된다. 
=> 따라서 디폴트값이 되는 기준은 매개변수의 값이 `undefined`냐 아니냐의 차이다.
## Arrow function
`=>` is  fat arrow.
Arrow functions do not have its own `this`, `arguments`.
자체에는 `arguments`가 존재하지 않는다. `this`를 잘 쓰지 않는다.
function의 범위에 arrow function이 포함되어있는 것이다. 완전히 대체가 되지 않기 때문에 적절한 상황에 맞춰서 써야한다.
## this
'나'라는 단어의 사용법과 비슷하다.
this는 문맥에 대한 정보를 가지고 있다.
this는 거의 대부분 객체다.
사용하는 이유는 인칭대명사처럼 유용하게 적용될 수 있기때문에 쓴다.
- 4가지 방식에 따라 this가 결정된다.

### 1) 일반 함수 호출
#### 1-1)  in non-strict mode
함수 일반 호출
전역(window)객체가 this이다.
#### 1-2) in strict mode
`'use strict';` 초기에 선언.
this가 전역객체를 가리키지 않는다.
### 2) 메소드 호출 (dot notation : 점 방식)
this는 메소드를 소유한 객체를 가리킨다.
메소드를 할당한 변수를 실행하면 윈도우객체를 가리킨다.
함수가 생성된 곳이 중요한 것이 아니라, 메소드 호출로 실행된 위치와 연관된다.
### 3) Explicit binding (call, apply, bind)
함수도 객체다. 
- call, apply는 첫번째 인자값으로 this값을 지정해줄 수 있다. 
call은 인자값을 첫번째 값 이후로 무한대로 받을 수 있다.
apply는 인자값을 배열만 받을 수 있다. 배열의 요소를 무한대로 넘겨줄 수 있다.
매개변수를 어떻게 받는지에 따라서 call, apply를 구분해서서서 쓴다.
- bind는 call, apply와 *비슷*하다.
원하는 Function 에 인자로 넘긴 this 가 바인딩 된 새로운 함수를 리턴한다.

### 4) 'new' keyword (생성자 함수 호출)
*new는 써야할 상황에 쓴다.*
new를 사용했을 때,
1) 빈 객체의 this를 생성한다.
2) 할당된 함수의 리턴값이 있더라도 this를 리턴한다.
단, 객체를 리턴하는 함수일 경우에는 this로 리턴되지 않는다.

## 0530
## Prototype
원래 형태 또는 기초.
## **Constructor function
생성자 함수 : new 키워드와 함께 쓰이는 함수
```js
new Array();
new Object();
new Function();
```
새로운 객체를 만들어낸다.
반드시해야하는 것은 아니지만, 일반 함수 인지 생성자 함수 인지에 따라서
*생성자 함수의 이름은 일반적으로 첫글자를 대문자로 한다.*
자바스크립트에서 거의 모든 객체는 생성자 함수를 이용해 만들 수 있다. 
(원시값은 객체처럼 포장하는 과정을 통해 던져지는 것. 절대 객체가 아니다.)

생성자 함수는 말 그대로 함수다.
모든 함수는 객체다.
고로 생성자 함수 또한 객체다.

원하는 대로 생성자 함수를 만들어 쓸 수 있다. 

하나의 함수가 만들어지면 하나의 프로토타입이 만들어지면서 그 안에 컨스트럭터가 또 생성된다. 반복한다. 함수를 만든다는 것은 하나의 부부를 동시에 만드는 것과 같다. 쌍으로 붙어서 산다.
## **Instance
남편과 남편의 아내의 사랑의 **결실**이다. 
생성자 함수를 사용해서 할당한 변수에는 인스턴스가 담긴다.
자식은 남편의 아내의 물건에 손을 대는 습성이 있다.
아이에게는 컨스트럭터라는 속성이 없지만 필요할때, **엄마에게**서 가져와서 쓴다.
-> 이러한 현상을 프로토타입체인(자식의 도벽)이라고 한다. 
자식이 필요할때는 자신의 것을 쓰지만 없다면 엄마의 것을 훔쳐온다. 자식이 변경 했을때 엄마의것은 건들지 못한다.

자식의 요구를 충족 시키기 위해 엄마에게서 찾지만 없으면 할머니에게서 찾는다.
마치 스코프체인과 흡사하다.

최상위에 오브젝트.프로토타입으로 끝난다.
오브젝트.프로토타입.던더프로토 => null
더이상 엄마가 없다.

## Dunder Proto
### __proto__
**아이**가 갖고 있는 엄마의 직접적인 정보
직접 엄마의 정보를 건드릴 수 있다.

var ken = new Person('ken huh');

ken.cosructor === Person;
ken.__proto__ === Person.prototype;

던더프로토를 쓰는 상황이 오면 일반적인 상황은 아니다.
### -> 이러한 효과를 상속이라고 한다. 
그러나 실제적인 상속과는 달리 잠시 빌려서 쓰는 것처럼 한다.
상속이라는 단어가 그리 어울리지는 않는다. 실제로는 상속이 일어나는 것이 아니라 대리시켜주는 효과와 같다.
-> **Behavior Delegation** (행동 위임, 대리시킨다.)
https://www.oreilly.com/library/view/you-dont-know/9781491905142/ch06.html

## +)
- 개발자 면접 볼때, 능력을 1-10 중에 무엇인지 물어본다.
- 10처럼 공부해라.
- 모든 함수는 프로토타입(키벨유를 가진)의 속성 또는 객체를 가지고 있다.
- 프로토타입 구조를 활용하진 않더라도 알고있어야 한다.

## 0531
-  **`String.substr()`**
지정된 인덱스에서 시작하여 지정된 문자 수만큼 확장하여 문자열의 일부를 새롭게 반환한다.
**`str.substr(start[, length])`**
start : 반환 할 문자열의 첫번째 문자 인덱스
length : start 인덱스부터 반환할 문자 수

# 0601
[Book] <프로그래머의 길, 멘토에게 묻다> ..내용 중
현실은 만만하지만은 않았을테지요. 프로그램 짜는 것만 잘하면 되는 줄 알았는데, 그것 말고도 신경써야 할 것들이 왜 그리도 많은지. 게다가 소프트웨어 개발이란 것은 과학은 아니고 공학이라기에는 아직 어설프고 예술이라고도 할 수 없이 어정쩡한, 아직은 그 중간의 어디쯤에 불안정하게 떠 있는 처지의 분야인지라, 많은 이들이 길을 안내해줄 누군가 혹은 그 무언가를 갈망하며 수많은 자기계잘 서적과 기술자료 사이로 오늘도 서성댄다.