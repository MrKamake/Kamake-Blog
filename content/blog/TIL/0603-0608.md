---
title: '0603-0608'
date: 2019-6-8 11:10:16
category: 'TIL'
---
## 0603
## 실행컨텍스트
자바스크립트의 핵심원리이다. 코드 독해와 디버깅을 위해 습득하고 있어야 한다. 
실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 쉽게 표현한다면 실행 가능한 모드가 되기 위해 필요한 환경이다.
- Global code
- `eval()` code
- function code
코드를 실행하기 위해 필요한 정보들은 변수(전역변수, 지역변수, 매개변수, 객체의 프로퍼티), 함수선언, 변수의 유효범위, this 가 있다.
이러한 정보들을 형상화하고 구분하기 위해서 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 

### 실행컨텍스트의 3가지 객체
- Variable Object
실행에 필요한 여러 정보들을 담을 변수 객체를 생성한다. 실행 될때 엔진에 의해 참조되며 코드에서는 접근할 수 없다.
=> 변수, 매개변수(parameter)와 인수 정보(arguments), 함수 선언(함수표현식은 제외)
전역 컨텍스트일 경우 VO는 유일하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체를 가리킨다. 
함수 컨텍스트의 경우 VO는 활성객체(변수객체)를 가리킨다. 매개변수와 인수들의 정보를 배열의 형태로 담고있는 객체인 arguments object가 추가된다.

### Scope Chain
스코프 체인은 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 **차례로** 저장하고 있다. 현재 실행 컨텍스트의 활성 객체를 선두로 하여 순차적으로 상위 컨텍스트의 활성 객체를 가리킨다. 마지막 리스트는 전역 객체를 가리킨다.
식별자 중에서 객체의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘이다. 
쉽게 말해 함수 객체가 처음 실행될 당시 실행 컨텍스트가 무엇인지를 생각해야하는 것이고 없다면 상위 컨텍스트로 옮겨가면서 찾아가는 것이다.
요약하자면 **스코프 체인 = 현재 실행 컨텍스트의 변수 객체 + 상위 컨텍스트의 스코프 체인** 

### this value
this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

## 클로저
생성된 함수 객체는 `[[Scopes]]`프로퍼티를 가지게 된다. `[[Scopes]]`프로퍼티는 함수 객체만이 소유하는 내부 프로퍼티로서 함수 객체가 실행되는 환경을 가리킨다. 따라서 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정한다. 내부 함수의 `[[Scopes]]`프로퍼팉는 자신의 실행 환경과 자신을 포함하는 외부 함수의 실행 환경과 전역 객체를 가리키는데 이때 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 `[[Scopes]]`프로퍼티가 가리키는 외부 함수의 실행환경은 소멸하지 않고 참조할 수 있다. 이것이 **클로저**이다.
-> **이미 생명 주기가 끝난 외부함수의 변수를 참조 하는 함수를 클로저라 한다.**
(실행 컨텍스트 관점으로 설명하면, 내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 컨텍스트가 반환되어도, 외부함수 실행컨텍스트 내의 활성 객체는 내부함수에 의해 참조되는 한 유효하다. 그래서 내부함수가 스코프체인을 통해 참조할 수 있다.)
클로저는 자신이 생성(선언)될때의 환경을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있다.
클로저가 가장 유용하게 사용되는 상황은 **현재 상태를 기억하고 변경된 최신 상태를 유지**하는 것이다. 
```js
function outerFunc() {
    var x = 1; // <- 자유 변수
    return function() { // <- 클로저
      /* x와 arguments를 활용한 로직*/
    }
}

var newFunc = outerFunc();
/* outerFunc 실행 컨텍스트가 끝났다 */
newFunc();
```
실행 컨텍스트가 끝났음에도 불구하고 읽기 및 쓰기가 가능하다.

### 클로저 사용시 주의 사항
- 클로저의 프로퍼티 값이 쓰기 가능하므로 그 값이 여러번 호출로 항상 변할 수 있다.
- 하나의 클로저가 여러함수 객체의 스코프 체인에 들어가 있는 경우도 있다.
- 루프 안에서 클로저를 활용 할때는 주의해야한다. 

# +)
- 자바스크립트에서 함수는 일급 객체로 취급한다. 함수를 다른 함수의 인자로 넘길 수 있고, return 으로 함수 통째로 반환 받을 수 있다. 
- 내부 함수에서 접근하는 변수 대부분이 스코프 체인의 첫번째 객체가 아닌 이후의 객체에 존재할 가능성이 높다. 성능 문제를 유발시키는 여지가 있다. 게다가 클로저를 사용한 코드가 그렇지 않은 코드보다 메모리 부담이 많아진다. 그렇다고 클로저라는 자바스크립트의 강력한 기능을 쓰지 않는 것은 슬픈일이다.라고 한다. *영리하게 사용하는 지혜*가 필요하다.

## 0604
## Recursion Function
자기 자신을 호출하는 함수
Iteratively solved와 함께 비교대상이다.
나는 읽는 것보다 코드 작성하는 것을 더 어렵게 느낀다. 
-가장 많이 사용하는 예제 : Factorial
재귀함수를 종료시킬 수 있는 조건을 꼭! 항상! 작성해야한다.
Base case, Termination case : 기본이 되고 끝장내는 케이스가 필요하다.
종료 구간을 꼭 작성하고 반드시 실행이 되어야 한다.

바뀌는 것을 매개변수로 받아야 한다.
처음부터 재귀를 쓰려하는 것이 아니라 문제를 펼쳐서 수식화 시킬 수 있는  요소를 찾아보기
길더라도 직접 쓰면서 확인해야한다. 두발자국이 아니라 한발자국씩 천천히 걸어라
## 클로저
자바스크립트에서 클로저는 생성(선언)되는 순간 어떤 함수가 본인이 선언된 주변 환경을 **지속적으로** 기억하는 것을 의미한다.
해당 함수가 실행되는 위치가 어디인지에는 관계 없다.
선언된 곳을 기준으로 주위를 접근할 수 있다.
**지속적으로** : 변경된 주위 환경까지도 계속 기억한다.

꼼꼼하게 탐구하면서 클로저를 공부하기
  < Watch out! >

  A thing to watch out for is that closures are the most common source of performance issues and memory leaks.Since
  the variables that are closed over might still be in use, they're either never or barely picked up by the garbage
  collection.

  Garbage collection (GC) is basically something that happens in the background to automatically manage the
  memory used by our application. Stuff that's no longer being used by the program takes up unnecessary memory, and the GC
  is responsible for cleaning it up.

  Garbage collection is something that you generally don't have to worry about, unless you're writing UI code that gets
  executed a lot

## +)
- Stack 구조 : 책을 쌓고 빼는 비유로 이해.
- 문제의 과정을 분석하고 분기(break-down)를 잘 나누어야 한다.
- 꼼꼼하고 천천히 가려는 것이 아니라 빨리가려고만 한다.

## 0605
## +)
-   두더지 잡기 게임을 설계하고 만든다. 로직을 수정하고 보완하고 쉽지않다. 이보다 스스로 심각하다고 판단되는 것은 자력으로 문제를 쪼개고 나누어서 차근차근 접근해서 하나씩 풀어가는 힘이 너무나도 부족하다는 것이다. 말그대로 문제해결능력을 지속적으로 키워야 할 것이다.

## 0606
HTML(Hyper Text Markeup Langage)은 우리 몸의 뼈대와 같은 역할을 하고 CSS는 우리 몸의 외모를 감강하고 Javascript는 우리 몸의 근육과 같은 역할을 한다. 모두 다른 역할을 하지만, 웹을 더욱 다이나믹하게 만들어주는 중요한 요소들이다.

## HTML
구성하는 기본단위는 **태그**이다. 
여는 태그를 썼다면 구분점을 명확히 하기위해 닫는 태그가 꼭 짝지어져서 써야한다.
`<html>` : 브라우저에게 HTML 코드가 해당 태그 내부에 존재한다고 알려준다.
`<head>` : 주로 외부 소스를 참조해야할때 사용한다.
`<body>` : 브라우저는 이 태그에 포함되어 있는 내용들을 화면에 보여주게 된다.

## CSS
css에는 두 가지를 유념할 필요있다. 브라우저에세 *무엇을 *바꾸고 싶은지 명령을 내리는 부분, 그리고 브라우저에게 *어떻게* 바꾸고 싶은지 명령 내리는 부분이 있다.
```css
body {
	color: red;
	font-size: 30px;
}
```
변경하려는 선택자를 명확하게 명시하는 것이 중요하다.
하지만 필요이상의 선택자를 생성하는 것은 지양해야한다.

### Descendent
```css
#nav li { // nav라는 ID값을 가진 요소의 하위에 존재하는 모든 li 태그 요소
	background: blue;
}
```
특정 요소의 하위 요소를 선택할때 사용된다. 두 개의 선택자 사이에 공백을 한 칸 주게되면 왼쪽의 선택자를 가진 HTML요소를 선택하게된다.
### Child
```css
#nav>li { 
	background: blue;
}
```
부등호를 사용하면 직속 자식 요소의 선택자를 성택핧 수 있다. 
### Universal
`*`를 선택자로 사용하면 페이지의 모든 요소들을 선택하는 방법이다.

## +)
- document.body.classList = "slfdksjdflkj"
이처럼 직접 변경하는 코드들이 많다. 전에 존재하던 정보를 무시하고 새로운 정보로 덮어씌우기 때문에 문제가 발생할 수 있다.
- 브라우저마다 CSS가 다르게 기본적으로 적용되어있다. Normalize나 Reset CSS를 사용해서 모든 브라우저에 통일되게 css를 적용시킬 수 있다.

## 0607
## CSS Layout
css는 보통 배치(Positioning)만 잘하면 끝난다.
### 1) Block VS Inline Block
HTML의 요소들은 *크게* 두 가지로 분류할 수 있다. 
- Block 요소는 지정되어있는 자리의 한 줄을 모두 차지한다.
: 너비와 높이의 설정이 가능, 또 다른 Block 요소를 자식으로 가질 수 있고, Inline 요소를 자식으로 가질 수 있다.
- Inline Block 요소는 문자처럼 채우는 만큼 자리를 차지한다.
:  너비와 높이의 설정이 불가능, 또 다른  Inline 요소를 자식으로 가질 수 있지만 Block 요소를 자식으로 가질 수 없다.
->임의적으로 디스플레이 설정으로 서로의 기능으로 변경할 수 있다.

### 2) Positioning
CSS를 이용해서 웹페이지 컨텐츠의 위치를 원하는 대로 조정할 수 있다. 
#### (1) Using Float
기본적으로 block요소로 순차적으로 쌓여져있던 상태에서 흐름이 깨져서 위치를 임의로 이동시킨다. 깨진 흐름을 해결하려면 여러가지 방법이 있지만 그 다음 요소에 clear를 입력하면 원상태의 흐름으로 돌려준다.
#### (2) Using Inline Block
display에 inline-block이라는 속성을 입력하게 되면 block이지만 inline block 처럼 한 줄에 배치된다.
#### (Using Flexbox)
Flexbox도 유용하게 활용할 수 있다.
#### (3) Using Position Property
Float과 Inline Block을 이용해서  소를 기본적으로 `position: static;`을 갖는다. 원한다면 `relative; absolute;`로 변경할 수 있다.
- Relative Position 는 이동할 위치값을 적용해주면 이동하는 속성.
- Absolute Position 는 기존의 위치는 유지되지 않고, 가장 가까운 부모 요소 중 `position: relative;`가 적용된 요소를 찾아 그 요소를 기준으로 위치가 잡히게 된다. relative 가 적용된 요소가 없다면 body를 기준으로 한다.

## +)
- Semantic markup (의미론적 마크업)
ex)` <header>, <section>, <aside>, <footer>`

## 0608
## DOM (Document Object Model)
DOM은 HTML이나 Javascript가 아니다.
1. 아이디어 구상
2. 설계도 작성
3. 실제 건축물 완성
HTML은 설계도, 브라우저는 실제 결과물을 제작하는 시공사 역할이라고 생각할 수 있다. 