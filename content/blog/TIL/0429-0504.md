---
title: '0429-0504'
date: 2019-5-4 12:00:00
category: 'TIL'
---
## 0429
- 프로토타입
: 자바스크립트는 프로그래밍 언어의 기존 C++이나 자바와 같은 객체지향 프로그래밍 언어와는 다른 **프로토타입 기반의 객체지향 프로그래밍**을 지원한다. 따라서 JS의 동작 과정을 제대로 이해하려면 프로토 타입의 개념도 잘 이해해야한다. 

 자바와 같은 객체지향 프로그래밍에서는 클래스를 정의하고 이를 통해 객체를 생성하지만, JS에서는 이러한 클래스 개념이 없다. 대신 객체 리터럴이나 생성자 함수로 객체를 생성할 수 있다. 이렇게 생성된 객체의 부모객체가 ***프로토타입*** 객체다. 상속개념과 마찬가지로 자식 객체는 부모객체가 가진 프로퍼티 접근이나 메서드를 상속받아 호출하는 것이 가능하다. 

 JS에서 모든 객체는 자신을 생성한 생성자 함수의 **prototype 프로퍼티**가가리키는 **프로토타입객체**를 자신의 부모 객체로 설정하는 **[[Prototype]] 링크**로 연결 한다.

 결국, 객체를 생성하는 것은 생성자 함수의 역할이지만, 생성된 객체의 실제 부모역할을 하는 것은 생성자 자신이 아닌 prototype 프로퍼티가 가리키는 프로토타입 객체다.

## 0430
## Object
```js
var obj = {
	name: 'kamake'
};
```
객체 내의 value(값)에는 자바스크립트에 존재하는 어떤 것이 들어와도 가능하다.
키값은 문자열로도 표기 가능하다. 왜냐면 결국 내부적으로 string으로 입력되기 때문이다.  자바스크립트에서 객체 내부적으로는 key값을 String으로 변환해서 인식하고 처리한다. 그렇기 때문에 그 키값을 필요에 의해 찾는 다면, 이해하고 찾아야 한다.

<B>객체의 키(속성, 프로퍼티), 벨유를 반복문을 하고싶다면 </B>

- for... in
  : 객체의 키값에는 순서가 정해져 있다고 장담할 수 없다. 임의대로 반복을 한다.

```js
var a = {
	name: 'kamake',
	age: 28
};

for(var prop in a) {
 console.log(prop);  // key 값을 가져올 수 있음음음음
 console.log(a[prop]); //value 값도 가져올 수 있음
}
```

```js
var kamake = 123;
var a = 'firstName';

var obj = {
	a: kamake; // 'firstName': 123
};

console.log(obj[''+'a'+''+'']) // 123 (결국 []에 남는 값이 키값과 같으면 된다.)
```

## +)
- 구조를 예쁘게 잘 짜는 것이 능력이다. => 자료구조 공부

## Array
 배열은 객체의 하위호환이라 생각하면 된다. 배열도 객체이기 때문에 어떤 타입의 값이 지정되어도 상관 없다.

- `unshift( )`, `pop( )` 는 배열의 앞, 뒤의 요소를 제거하고, 제거된 요소를 반환한다. 단, 빈 배열일 경우 `undefined`를 반환한다.
- `shift(z)`, `push(z)` 는 배열의 가장 앞, 뒤에 새로운 요소 `z`를 추가하고, 배열의 새로운 길이를 반환한다.

## +)
- JS에서 배열은 객체지만 순서가 있다. (index)
- 객체와 같이 요소는 무엇이든지 가능
- 문자열은 이미 저장된 상태이므로 할당된 값 자체를 직접 변경시킬 수 없다. (값을 활용해서 분해시켜서 중간중간 요소나 전체 정보를 변경시킬 수 있다.)
- 메소드를 공부 할때 중요한 것은 **디테일하게** 무엇이 매개변수가 되고 반환되는지 알아야 한다. 기본적인 "설명"부터 읽고 이해해야 한다. "기본예제"를 파악해야한다. "구문"항목도 기억해야한다. 

## Primitive vs Reference
모든 값은 그 성격에 따라 구분 할 수 있다.
### 1) Primitive(원시적인)
#### - Type
- Boolean
- Number
- String
- Null
- Undefined
```shell
Q. 할당되어 있지 않는 값을 찾게 되면 null이 아니라 undefined로 표현되는 것일까?
(값이 없는 것이라면 undefined가 아닌 아무 값조차 없는 null이 어울리지 않을까?)
A. 자바스크립트에서는 모든 변수를 선언하는 동시에 값이 주어진다.
(명시적으로 정하지 않으면 undefined가 암시적으로 주어진다.)
```
변수에 Primitive 값을 할당하고 값을 비교할때, 같은 값이면 같다라고 치부하는 것이다. 
변수에 이미 할당된 값을 새로운 값으로 할당 한다면 전에 존재했던 값은 재활용하지 못한다. ( 값에 할당된 메모리 주소를 재활용하지 않고 새롭게 메모리 주소를 링크해서 그 값을 변수에 할당 해준다. )

### 2) Reference
 값의 생김새(타입, 값)가 같아 보여도 참조하고 있는 위치가 다르다면 같은 값이라 보기 어렵다. JS는 **객체를 *생성하면* 새로운 장소에 저장**한다. 위치는 항상 다를 수 박에 없는 성질이 있다. 특수한 객체인 배열과 함수 모두 객체에 포함되기 때문에 저장된 위치를 꼼꼼히 신경 써야 한다. 
- 변수에 참조된 주소는 같지만 할당된 정보는 다르다.
- 위치를 기준으로 비교를 하게 된다. 
- 변수에 할당할 객체를 새롭게 생성한다면 객체의 위치를 변수에 저장 시켜놓는다.
객체를 비교해서 위치를 신경써야하는 것이 아니라 변수를 비교할 때는 어디에 담겨있는지와는 상관없이 그 변수만을 판단하면 된다.

## +)
- 내가 사용할 수 있는 재료들에 대해 공부하는 것.  얼마나 잘 조합할 수 있는지, 마치 전쟁터에서 군인들을 적재적소에 배치해서 뛰어난 용병술을 가지는 것이 중요하다.
- 개념들을 알고 지나가는 것이 아니라 **직접 사용해보면서 인지하고 기억하기!** 
- 꼼꼼히 읽으면서 공부 & 작업하기
- 문서(article)에서 영단어를 만나면 의미를 먼저 파악해라.

## 0501
## +)
- `this`를 파악할때 네 가지 방식을 잘 기억해서 써먹자
  1) 함수 호출, 2) 메소드 호출, 3) 생성자 함수, 4)  apply / call / bind 호출
  함수의 기본 메소드인 `call()`, `apply()`는 함수 호출할 때, `bind()`는 함수를 선언하는 단계일 때 쓴다.
- 학업 스케줄을 할 수 있는 것보다 조금 높게 계획해서 성취감을 느낄 수 있게 하기
- 열심히 좀 해봅시다ㅏ...허허

## 0502
## 1) Scope
어떤 변수들의 접근 가능한 법위를 결정하는 것
### (1) function scope
**- var**
**본인이 속한 함수 내에서만 접근 가능하게 해주는 기능**을 가지고 있다.
내부에서 외부는 접근 가능 / 외부에서 내부는 접근 불가능
내부, 외부의 범위를 판별하는 기준은 함수(블럭) 단위 이다.
```js
var a = 1;
function foo() {
	var b = 2;
	function foo() {
	console.log(b);	// 2
	}
	console.log(a);	// 1
	console.log(b);	// 2
}
foo();
console.log(b);	// undefined
```
콘솔로그는 스코프를 따라 타고 올라가면서 범위에 있는 요소들을 모두 확인한다. 스코프 내에 부재할 시 해당 스코프를 감싸는 상위 스코프에서 찾는다. 글로벌스코프까지 도달해도 찾지 못한다면 ERROR가 발생한다.
### (2) IIFE
즉시 실행 함수 (Immediately Invoked Function Expression)
임의로 함수를 만들어서 정확한 **범위 지정**한다.
외부에서 함수 내부의 변수를 접근하지 못하도록 감싸고 막는 느낌. 그래서 즉시 실행함수 외부에서 내부에 있는 함수를 호출하지 못한다.
함수선언식과 호출하는 방법으로 범위를 지정해주더라도 함수도 변수이므로 변경 가능성이 있기 떄문에 즉시실행함수로 표현해주면 보다 정확하다.
### (3) Global Scope
(Global Variable, Global Object)
스코프는 계층적으로 이루어져 있다. 가장 바탕에 위치하는 스코프가 글로벌 스코프다. 프로그램이 시작되면 항상 하나가 존재한다.
전역 스코프에 선언한 것은 모든 스코프에서 볼 수 있다. 공용공간인 거실(라운지)과 같은 존재. 모두 접근하고 사용할 수 있기 때문에 조심해서 사용해야한다.
특수한 환경이 아닌 이상 일반적인 상황에서는 자제하는 것이 좋다. 글로벌스코프는 개발자들이 최대한 쓰니 않으려 한다. 그래서 즉시 실행함수를 만들어 쓴다.
## +)
- 실행 : call, invoke, excute
- Scope Chain이라는 것은 기본적으로 해당하는 스코프에서 최대한 찾다가 찾을때까지 상위 스코프로 타고 올라가다 결국 글로벌 스코프까지 도달한다.
- 스코프의 성격을 알고 프로그래밍 작업을 해야한다. 이유가 있지 않는 한 글로벌 스코프의 공용공간에 두지 않는 것이 좋다.
- 일부 언어는 선언(declaration)과 정의(definition)를 명확히 구분한다. 일반적으로 변수를 선언한다는 것은 식별자를 주어서 그 존재를 알리는 것이다. 반면 정의는 *선언과 함께* 값도 부여하는 것을 말한다. 자바스크립트에서는 모든 변수를 선언하는 동시에 값이 주어지므로(명시적으로 정하지 않으면 undefined가 암시적으로 주어지므로) 두 용어를 구분하지 않는다.

## 2) Hoisting
- 보통 끌어올리는 장비를 호이스트라고 일컫는다.
- 그렇다면 자바스크립트에서는 무엇을 끌어올릴까?
- 호이스트 된 것처럼 동작한다.
```js
console.log(a); // 'a' is not defined가아니라 undefined다.

var a = 1;

console.log(a); // 1
```
첫번째 콘솔로그에서 3번째줄에 있는 변수를 선언하면서  hoist한다. (속해있는 스코프내에서 끌어올린다.)
자바스크립트를 실행할때, 호이스팅이 가장 먼저 작동된다.

### Function Declaration
함수 선언식은 함수를 선언(정의)하는 동시에  스코프 함수를 전체적으로 맨 위로 끌어올린다. 따라서 함수를 선언하기 전에 호출할 수 있다. 현재 속한 스코프 내에서 최상단으로 호이스트된다.
```js
foo();

function foo() {
console.log(a);
}
```
### Function Expression
함수 표현식은 끌어올리지 않는다. 변수의 스코프 규칙을 그대로 따른다. 그래서 표현식 이전에 호출해서 활용할 수 없다.
함수 선언식과 다르게 함수 표현식은 문이기 때문에 `;`를 마지막에 붙여줘야 한다.
```js
d(); // ReferenceError : d 는 정의되지 않았습니다.

var d = function () {
	console.log('I am inside function d');
};

d(); // 'I am inside function d'
```
지금과 같은 함수표현식 예제에서는 첫번째 함수호출에서는 함수가 호이스팅이 되지 않고 할당되지 않은 `var d`가 호이스팅되고 `undefined`로 에러가 된다.
## +)
- Function Declaration VS Function Expression
  :  취향에 따라, *회사에 따라* 한 가지를 정해서 통일성있게 쓰도록 해야한다.
- Code Style
  : [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)를 많이 따르는 추세다.
- 함수 내에서 return문은 개행(줄바꿈) 시키면 문장이 끝난 것이다.

## 0503
## +) 
- Function Declaration VS Function Expression
  : 함수 선언식과 함수 표현식의 비교하면서 이때까지는 자바스크립트는 유연한 언어 중 하나로써 프로그래밍을 하는 과정에 있어서 호이스팅이라는 것을 늘 위험요소라 생각했었다. 그래서 함수표현식을 쓰면서 전달하려는 의미를 명료하고 정확하게 전달해야겠다라는 생각했었다. 하지만 어제 *켄님*의 강의를 통해서 사고를 확장시킬 수 있었다. 이전의 생각들은 호이스팅이 자바스크립트에서 어떻게 이루어지고 활용이 되는지에 대해 얼핏알고 있었기 떄문에(아니, 몰랐다라고 표현하는 것이 더 낫겠다.) 함수 표현식만 좋을 것이라는 생각을 한것 같다. 스코프와 호이스팅을 강의를 통해 배우면서 자바스크립트가 어떻게 동작하는지 배웠다. 오히려 *켄님*의 생각처럼 함수 표현식을 씀으로써 한번더 고려해줄 필요 없이 자바스크립트의 동작을 정확히 이해하고 그것을 활용하면 된다.라는 사고의 확장이 이루어졌다. 물론 또 공부를 하면서 더 나은 코딩에 대한 생각이 바뀌겠지만 머릿속에 정확히 입력시키기 위해서 정리해봤다. 

## 0504
- <프로그래머의 길, 멘토에게 묻다> -데이브 후버, 애디웨일 오시나이 지음-
  <이자벨 버턴 부인의 저서 중에서 인용한 아랍 속담>
  - 알지 못하여 그 사실도 모르는 자, 바보로다 - 그를 멀리하라!
  - 알지 못하나 그 사실을 아는 자, 못 배운 자로다 - 그를 가르치라!
  - 알고 있으나 그 사실을 모르는 자, 잠든 자로다 - 그를 깨우라!
  - 알고 있으며 그 사실을 아는 자, 깨우친 자로다. - 그를 따르라!
 : 책의 목표는 동기부여나 의욕에 관련한 것들을 풀어내어 도움을 준다는 것이다. 책에서는 패턴이 많이 등장한다고 한다. 모두 '상황', '문제', '해결책', '실천 방안'으로 이루어져 있다. '상황'은 전반적인 분위기를 설정해주고, '문제' 서술부는 이 패턴에 의해 해결되는 문제가 무엇인지 알려줍니다. '해결책'부분은 대게 해법을 한 문장으로 요약한 다음, 해결책을 적용할 때 생기는 이슈에 대해 더 자세히 다룬다.패턴의 마지막 에는 '실천 방안'이 있다. 패턴의 효과를 경험하고자 할 때 즉시 실천할 수 있는 구체적인 사항이 담겨있다.

 나만의 견습과정을 정의하는 것에 도움이 될 만한 내용을 나만의 것으로 알맞게 습득해야겠다.
 