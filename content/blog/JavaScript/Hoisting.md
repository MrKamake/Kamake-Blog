---
title: 'Hoisting'
date: 2019-7-5 11:40:43
category: 'Javascript'
---

보통 끌어올리는 장비를 호이스트라고 일컫는다. 그렇다면 자바스크립트에서는 무엇을 끌어올린다는 것일까? 예제를 살펴보면서 알아보자.

```js
console.log(a) // 'a' is not defined가아니라 undefined다.

var a = 1

console.log(a) // 1
```

첫번째 콘솔로그에서 3번째줄에 있는 변수를 선언하면서 Hoist한다. (속해있는 스코프내에서 끌어올린다.) 엔진이 코드를 실행할때, 호이스팅이 가장 먼저 작동된다.

**호이스팅(Hoisting)**이란, var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다. 변수가 어떻게 생성되며 호이스팅은 어떻게 이루어지는지 좀 더 자세히 살펴보자. 변수는 3단계에 걸쳐 생성된다.

1. 선언 단계(Declaration phase)
   변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다.
2. 초기화 단계(Initialization phase)
   변수 객체(Variable Object)에 등록된 변수를 위한 공간을 메모리에 확보한다. 이 단계에서 변수는 undefined로 초기화된다.
3. 할당 단계(Assignment phase)
   undefined로 초기화된 변수에 실제 값을 할당한다.

> ### Function Declaration

함수 선언식은 함수를 선언(정의)하는 동시에 함수를 현재 속한 스코프 내에서 최상단으로 호이스트된다.**따라서 함수를 선언하기 전에 호출할 수 있다**.

```js
foo()

function foo() {
  console.log(a)
}
```

> ### Function Expression

함수 표현식은 끌어올리지 않는다. 변수의 스코프 규칙을 그대로 따른다. 그래서 표현식을 선언과 할당하기 전에 호출해서 활용할 수 없다. 함수 선언식과 다르게 함수 표현식은 문(State)이기 때문에 `;`를 마지막에 꼭 붙여줘야 한다.

```js
d() // ReferenceError : d 는 정의되지 않았습니다.

var d = function() {
  console.log('I am inside function d')
}

d() // 'I am inside function d'
```

지금과 같은 함수표현식 예제에서는 첫번째 함수호출에서는 함수가 호이스팅이 되지 않고 할당되지 않은 `var d`가 호이스팅되고 `undefined`로 ReferenceError가 발생한다.

> ### Class Hoisting

**함수 선언**과 **클래스 선언**의 중요한 차이점은 함수 선언의 경우 호이스팅이 일어나지만, 클래스 선언은 그렇지 않다. 클래스를 사용하기 위해서는 클래스를 먼저 선언해야 하며, 그렇지 않으면 ReferenceError 에러가 나타난다.

```js
var p = new Polygon() // ReferenceError

class Polygon {}
```

> ### 참고

- Function Declaration VS Function Expression

  : 취향이나 회사에 따라 한 가지를 정해서 통일성있게 쓰는 것이 일반적이라고 한다.

  : 함수 선언식과 함수 표현식의 비교하면서 지금까지는 자바스크립트는 유연한 언어 중 하나로써 프로그래밍을 하는 과정에 있어서 호이스팅이라는 것은 늘 위험요소라 생각했었다. 그래서 함수표현식을 쓰면서 전달하려는 의미를 명료하고 정확하게 전달해야겠다라는 생각했었다. 호이스팅이 자바스크립트에서 어떻게 실행과 활용이 되는지 얼핏 알고 있었기 때문에(아니, 몰랐다라고 표현하는 것이 더 낫겠다.) 함수 표현식만 좋을 것이라는 생각을 한것 같다. 하지만 스코프와 호이스팅을 자세하게 공부하면서 사고를 확장시킬 수 있었다. 선언식과 함께 호이스팅을 잘 쓴다면 좋겠지만 함수 표현식을 씀으로써 한번더 고려해줄 필요 없이 '자바스크립트의 동작을 정확히 이해하고 그것을 활용하면 된다'라는 사고의 확장이 이뤄졌다. 물론 또 공부를 하면서 더 나은 코딩에 대한 생각이 바뀌겠지만 정리해봤다.

- `var` vs `let`

  : `var` 키워드로 선언된 변수는 `선언 단계와 초기화 단계가 한번`에 이루어진다. 즉, 스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화(초기화 단계)한다. 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라 한다.

  : `let` 키워드로 선언된 변수는 `선언 단계와 초기화 단계가 분리`되어 진행된다. 즉, 스코프에 변수를 등록(선언단계)하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다. 초기화 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다. 이는 변수가 아직 초기화되지 않았기 때문이다. 다시 말하면 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 ‘일시적 사각지대(Temporal Dead Zone; TDZ)’라고 부른다.
